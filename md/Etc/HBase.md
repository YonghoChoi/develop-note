# HBase

* HDFS 기반으로 구현한 컬럼 기반 분산 데이터베이스(distributed column-oriented database)
* 대규모 데이터셋에서 실시간으로 읽고 쓰는 랜덤 엑세스가 필요할 때 사용할 수 있는 하둡 애플리케이션
* RDBMS가 대규모 확장성과 분산을 염두에 두고 개발된 것이 아니기 때문에 복제 및 분할에 어려움이 있음.
  * 특히나 확장된 RDBMS에서 조인, 복합쿼리, 트리거, 뷰, 외부키 제약을 실행하면 엄청난 비용이 발생
* HBase는 단지 노드만 추가하면 선형으로 확장할 수 있는 기반부터 구축
* HBase는 관계형 구조가 아님
* SQL을 지원하지 않음



## 개념

### 데이터 모델

* 애플리케이션은 테이블에 데이터를 저장
* 테이블은 로우와 컬럼으로 이루어져 있다.
* 테이블의 셀(로우와 컬럼의 교차점)은 버전별로 관리된다.
  * 버전은 셀이 생성되거나 갱신될 때마다 HBase가 자동으로 할당하는 타임스탬프
  * 셀의 내용은 바이트 배열
* 테이블 로우 키도 바이트 배열
  * 이론적으로 문자열부터 long형의 바이너리 표현, 심지어 직렬화된 데이터 구조까지 어떠한 것도 로우 키로 사용할 수 있다.
* 테이블의 로우는 테이블의 primary key인 로우 키로 정렬된다.
  * 정렬은 바이트 순서
* 모든 테이블은 primary key를 통해 접근할 수 있다.
  * 다른 컬럼에 대한 인덱스(2차 인덱스 또는 보조 인덱스)를 지원하지 않는다.
* 로우의 컬럼들은 컬럼 패밀리로 그룹지어진다.
  * 모든 컬럼 패밀리는 공통 접두사를 가짐
  * 예) info:format과 info:geo 컬럼은 모두 info 컬럼 패밀리의 멤버
* 컬럼 패밀리의 접두사는 출력 가능한 문자로 이루어져야 한다.
* 컬럼 패밀리와 식별값은 항상 콜론 (:)으로 나뉜다.
* 테이블의 컬럼 패밀리는 테이블 스키마를 정의할 때 미리 지정되어야 하지만, 새로운 컬럼 패밀리 멤버는 언제든지 추가할 수 있다.
  * 예) 컬럼 패밀리 info가 테이블에 이미 존재하면 새로운 컬럼 info:camera와 저장할 값을 업데이트 동작으로 넣을 수 있다.
* 물리적으로 모든 컬럼 패밀리 멤버는 파일시스템에 함께 저장된다.



### 리전

* HBase는 테이블을 자동으로 리전 단위로 수평 분할한다.
* 각 리전은 테이블의 로우의 부분집합으로 구성된다.
* 리전은 자신이 속한 테이블, 첫번째 로우(포함), 마지막 로우(제외)로 정의된다.
* 초기에 테이블은 단일 리전만 존재
  * 처음 분할될 때까지 모든 로딩은 초기 리전을 호스팅하는 단일 서버에서 일어난다.
* 리전이 점차적으로 커지면서 설정된 임계 크기를 넘어서면 하나의 로우를 경계로 대략 동일한 크기의 새로운 리전 두개로 분할된다.
  * 테이블이 커지면서 리전 개수도 증가
* 리전은 HBase 클러스터에 분산되는 단위
* 하나의 서버가 감당하기에 큰 테이블도 서버 클러스터에서 다뤄질 수 있다.
  * 이를 위해 각 서버는 테이블의 전체 리전의 일부분을 호스팅한다.
* 즉, 가동되고 있는 정렬된 리전 집합은 테이블의 전체 내용을 나눠서 보관한다.
  * HBase가 테이블의 데이터 로드를 분산시키는 방식



### 락킹

* 로우 업데이트는 로우 수준 트랜잭션에 포함된 로우 컬럼의 개수와 상관없이 원자적(atomic)



## 구현

* HBase는 하나 이상의 리전 서버 워커로 구성된 클러스터를 조율하는 HBase 마스터 노드로 이루어진다.



### 마스터의 역할

* 마스터는 최초 설치를 부트스트랩핑 하는 역할을 수행
  * 부트스트랩핑 : 운영체제 또는 시스템을 초기화하거나 준비 상태로 만드는 일련의 작업
* 등록된 리전 서버에 리전을 할당
* 실패한 리전 서버를 복구



### 리전 서버의 역할

* 0개 이상의 리전을 다룬다.
* 클라이언트의 읽기/쓰기 요청을 처리한다.
* 리전 스플릿을 관리한다.
* 새로운 자식 리전을 HBase 마스터에게 알려준다.
  * 마스터가 부모 리전과의 연결을 끊고 대신 자식을 할당하게 한다.



### 주키퍼의 역할

* HBase는 주키퍼에 의존한다.
* 기본적으로 클러스터 상태를 지휘하는 주키퍼 인스턴스를 자체 관리하지만, 이미 존재하는 주키퍼 클러스터를 대신 이용하도록 설정할 수 있다.
* 주키퍼 앙상블은 hbase:meta 카탈로그 테이블의 위치, 현재 클러스터 마스터의 주소와 같은 아주 중요한 값을 가진다.
* 주키퍼는 중간에 리전을 할당할 때 참여하는 서버들간의 충돌을 중재한다.
* 할당 트랜잭션 상태를 관리한다.
  * 고장나서 제외된 서버가 내버린 리전을 알아서 복구할 수 있다.
* 적어도 HBase 클러스터에 클라이언트 연결을 시작할 때 클라이언트는 주키퍼 앙상블의 위치를 전달받아야 한다.
  * 그 후 클라이언트는 서버 위치와 같은 클러스터 속성을 알기 위해 주키퍼의 계층도를 탐색한다.



### 설정 파일

* 리전 서버 워커 노드는 HBase conf/regionservers 파일에 나열되어 있다.
* 시작과 종료 스크립트는 원격 명령을 실행하기 위해 동일한 SSH 기반 메커니즘을 사용한다.
* HBase conf/hbase-site.xml과 conf/hbase-env.sh에 클러스터의 사이트 환경 설정을 한다.
  * 하둡 부모 프로젝트의 환경 설정과 동일한 형태
* HBase는 하둡 파일시스템 API를 통해 데이터를 저장
* 대부분 HDFS 위에서 HBase를 실행하지만 지정하지 않을 경우 기본적으로 로컬 파일시스템에 기록한다.
  * 로컬 파일시스템 사용은 테스트 환경에서는 좋지만 클러스터를 사용하려면 HDFS 위에서 실행해야한다.



### hbase:meta

* 내부적으로 HBase는 hbase:meta로 명명된 특별한 카탈로그 테이블을 가진다.
  * 클러스터에 존재하는 모든 사용자 공간(user-space) 리전의 현재 목록, 상태, 위치를 관리
* hbase:meta의 요소로는 리전명을 키로 가진다.
  * 리전명은 리전이 속한 테이블의 이름, 리전의 시작 로우, 생성 시간, 이 모든 것의 MD5 해시값으로 구성
  * 쉼표로 구분
  * MD5 해시 값은 처음과 끝이 점으로 둘러싸여 있음
* 리전 상태가 전환되면 카탈로그 테이블을 갱신해서 클러스터의 모든 리전의 상태를 최신 값으로 유지한다.
  * 상태 전환 요소
    * 분할, 비활성, 활성, 삭제, 리전 로드 밸런서나 리전서버 강제 종료로 인해 재배포



### 클라이언트의 접근 절차

1. 새로운 클라이언트는 주키퍼 클러스터에 먼저 접속하여 hbase:meta의 위치를 알게된다.
2. 적절한 hbase:meta 리전을 검색해서 사용자 공간 리전을 관리하는 서버와 위치를 알아낸다.
3. 이 후 해당 리전 서버와 직접 소통한다.



### 캐싱

* 로우 동작마다 세 번의 왕복 통신이 이루어지는 부담을 줄이기 위해 클라이언트는 hbase:meta를 조회하는 동안에 알게 된 모든 것을 캐시한다.
* 장애가 발생하면(즉, 리전이 이동하면) 클라이언트는 새로운 위치를 알기 위해 hbase:meta 테이블에 다시 문의한다.



### 쓰기 요청

* 쓰기 요청이 리전 서버에 도착하면 먼저 커밋 로그에 추가되고 메모리 내의 멤스토어(memstore)에 추가된다.
  * 멤스토어가 가득차면 내용물을 파일시스템에 플러시
* 커밋 로그는 HDFS에 저장되므로 리전서버에 장애가 발생하더라도 가용하다.
* 마스터는 리전 서버가 더 이상 접근 불가함을 알게 되면 죽은 리전 서버의 커밋 로그를 리전 단위로 분할한다.
  * 보통 주키퍼 내 서버의 znode가 만료되었기 때문
* 재할당 과정에서 죽은 리전 서버에 있던 리전은 비즈니스 재개 전에 아직 저장되지 않은 막 분할된 편집 파일을 골라 재생하여 실패하기 직전의 최신 상태로 만든다.



### 읽기 요청

* 읽기 요청에는 먼저 리전의 멤스토어에 접근
  * 멤스토어만 읽고 적합한 버전을 찾는 다면 쿼리는 여기서 완료
  * 적합한 버전이 존재하지 않을 경우 최근 플러시 파일부터 오래된 순으로 쿼리를 만족하는 버전을 발견하거나 더 이상 플러시 파일이 없을 때까지 탐색한다.
* 백그라운드 프로세스는 저장된 파일의 개수가 임계치를 넘어서면 하나의 파일로 압축한다.
  * 읽을 파일의 개수가 적을 수록 성능이 더욱 좋아지기 때문
* 압축 도중에 프로세스는 설정된 최대 버전을 넘는 것은 정리하고 삭제되었거나 만료된 셀은 제거한다.
* 리전서버에서 실행 중인 별도의 프로세스에서 플러시 파일 크기를 감시하고 이 크기가 설정된 최댓값을 넘어서면 리전을 나눈다.

