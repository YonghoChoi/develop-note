# 인터넷

## 패킷 스위칭

* 지리적으로 떨어져 설치된 컴퓨팅 자원에 서로 다른 장소에서 일하는 과학자가 접근하기 위한 연결 수단이 필요
* 그 전까지는 장거리 통신에서 서킷 스위칭(circuit switching) 사용
  * 송수신 단말 사이에 회로(circuit) 연결을 해두고 정보 전달 수행
  * 회로보다 작은 단위인 회선(line)을 길게 짜 맞추어 연결한 것
  * 송수신이 일어나는 동안 연결 유지. 전용선
  * 회선은 모든 송수신이 끝날 때까지 그 연결 전용으로만 사용해야 함.
  * 통신이 끝나면 회선 사이의 연결을 모두 끊은 후 다른 정보를 송수신하기 위해 각각 다른 회선과 다시 연결.
  * 가용성 면에서 제한적
* 패킷 스위칭은 하나의 송수신에 회선을 전용으로 할당해야 할 필요가 없으므로 가용성을 높일 수 있다.
  * 회선 자체는 공유하되, 송수신 내용을 패킷이라는 작은 뭉치로 나눈 뒤 저장 후 전달(store and forward) 절차를 사용
  * 네트워크의 각 노드는 같은 네트워크의 여러 노드에 연결되고, 연결된 회선으로 노드 사이에 패킷을 주고 받을 수 있다.
  * 각각의 노드는 수신한 패킷을 저장하고 이후 목적지에 가까운 다른 노드로 이를 전달
  * 서킷 스위칭과 비교해 가장 중요한 차이점은 같은 회선을 이용해 여러 노드로의 송수신이 동시에 진행될 수 있다는 점.
  * 한번에 많은 송수신 패킷을 처리할 수 있으므로 가용성 증대.
* 패킷 스위칭 자체는 추상화된 개념.
* 구체화 하기 위해 네트워크의 각 노드가 어떻게 데이터 패킷을 꾸릴지, 어떻게 패킷을 네트워크를 통해 보낼지를 정형화해 둔 프로토콜이 필요
* 이렇게 발전한 프로토콜을 통칭해 TCP/IP 스택 또는 TCP/IP Suite라고 한다.





## TCP/IP 스택의 계층 구조

* 목적에 따라 여러 프로토콜을 갈아 끼울 수 있게 계층을 추상화하여 나누고, 각 계층이 저마다의 소임에 충실할 수 있게끔 설계하여 각기 독립적인 계층이 다른 계층을 뒷바침하고 데이터를 적절히 연계할 수 있다.
* 우아하게만 보이는 TCP/IP 스택에도 여기저기 땜질한 자국도 많이 보이는데 프로토콜 작성자마다 성능이니 확장성이니 하는 핑계로 쓸모있긴 하지만 설계 철학에 반하는 복잡한 예외사항으로 범벅을 해두었다.
* 게임 제작에는 주로 TCP/IP의 상위 계층을 주로 다룸
  * 최적화를 위해서는 하위 계층이 어떻게 동작하는지, 상위 계층과는 어떤 식으로 상호작용하는지 알아두는 것이 좋다.
* OSI 7계층 중 게임 개발과 관련이 있는 물리/링크/네트워크/전송/응용 계층에 대해 살펴본다.
* 각 계층은 저마다 자기 윗단 계층을 지원하기 위해 수행해야 하는 역할이 있다.
  1. 윗단 계층에서 데이터 블록을 수신
  2. 계층 헤더를 추가해 패킷을 꾸린다
  3. 데이터를 아랫단 계층으로 전달해 송신 과정을 계속해 나간다.
  4. 아랫단 계층에서 수신된 데이터를 받는다.
  5. 헤더를 제거하여 수신된 데이터의 패킷을 푼다.
  6. 수신된 데이터를 윗단 계층으로 전달해 수신처리를 계속해 나간다.
* 객체지향에 비유하자면 계층은 인터페이스, 각 프로토콜이나 프로토콜 집합은 그 인터페이스를 구체화한 구현물.
* 각 계층마다 헤더를 가지고 있고 층을 거쳐갈 수록 헤더를 붙이거나 제거하는 식으로 전달됨.

![](images/internet_1.JPG)



### 물리 계층

* 가장 기본적인 하드웨어 전송을 지원
* 네트워크로 연결된 컴퓨터, 즉 호스트 사이의 물리적 연결을 책임짐
* 물리적으로 연결된 매체가 있어야 정보 전달이 가능
  * 전화선, 동축케이블, 광섬유케이블 등
  * 핸드폰, 노트북과 같은 전파를 사용한 정보 전달도 포함



### 링크 계층

* 전자기학을 벗어나 컴퓨터학이 본격적으로 적용되는 곳

* 송신 호스트가 정보를 꾸려 물리 계층을 통해 정보를 보낼 수 있는 수단, 그리고 수신 호스트가 높은 확률로 그 정보를 수신하여 안에 담긴 정보를 꺼낼 수 있게 하는 수단을 제공

* 링크 계층의 송수신 단위를 프레임(frame)이라고 함.

* 링크 계층의 역할

  * 특정 목적지에 주소를 부여해서 각 프레임에 기재토록 하여 호스트를 식별할 수단 제공
  * 수신 측 주소와 데이터를 담을 수 있는 프레임 포맷 정의
  * 한 번에 데이터를 얼마까지 보낼 수 있는지 윗단 계층에서 알 수 있게끔 프레임의 최대 길이를 정의
  * 물리 계층을 거쳐 전달된 신호를 의도된 호스트가 수신할 수 있게 프레임을 물리적인 전기 신호로 변환하는 방법 정의

* 의도된 호스트에 프레임이 전달될지 아닐지는 확률적으로 결정되며 항상 보장되는 것은 아니라는 점에 유의

* 링크 계층에서는 프레임이 도착하였는지 확인하거나 실패하였을 때 다시 보내는 등의 시도를 전혀 하지 않는다.

  * 이러한 이유로 링크 계층을 비신뢰성(unreliable) 통신이라 함.

* 물리 계층을 구현하고자 하는 물리적 연결 매체마다 대응되는 하나 이상의 프로토콜이 링크 계층에 존재

  * 랜선 연결은 1000BASE-T 같은 이더넷 계열 프로토콜로 통신

  * 전파 연결은 와이파이 프로토콜 또는 장거리 무선 프로토콜인 3G나 4G로 통신

    ![](images/internet_2.JPG)

* 링크 계층의 구현물과 물리 계층의 연결 매체가 서로 밀접하게 연관되어 있다 보니 일부 모형에서는 이 두 가지를 합쳐 하나의 계층으로 묘사하기도 한다.

  * 하나 이상의 링크 계층 프로토콜을 지원하는 물리적 연결 매체도 있으므로, 서로 다른 계층으로 구별해 두는 편이 좋음.

* 두 호스트 사이에 꼭 한 벌의 물리적 연결 매체와 링크 계층 프로토콜 조합만 쓰는 것은 아니다.

  * 한뭉치의 데이터를 보내는 과정에서 데이터가 서로 다른 여러 매체와 링크 프로토콜을 거쳐 갈 수도 있다.
  * 즉, 네트워크 게임을 하면서 발생하는 데이터를 송신하는 과정에서, 다양한 링크 계층 프로토콜이 두루 이용될 수 있다.

* 다양한 링크 계층 프로토콜 중에서 가장 많이 접하게 되는 이더넷에 대해서는 알아둘 필요가 있다.



#### 이더넷/802.3

* 이더넷은 프로토콜 하나가 아니라 이더넷 블루북 표준에 근거한 프로토콜 그룹이다.

* 이더넷 표준은 1980년도 DEC, 인텔, 제록스가 공동으로 제창

* 오늘날 이더넷 프로토콜은 IEEE 802.3 표준으로 정의

* 광섬유, TP 케이블, 동축 케이블 등 매체마다 상응하는 이더넷 파생 프로토콜이 있다.

  * 속도에 따라 파생되는 프로토콜도 있음

* 여러 호스트를 식별하기 위해 이더넷에서는 매체 접근 제어 주소(Media Access Control address. MAC)를 사용

  * MAC 주소는 이론상 고유한 48비트 숫자
  * 이더넷 네트워크에 연결 가능한 장비 하나하나 마다 고유한 값으로 부여
    * 이러한 장비를 통칭하여 네트워크 인터페이스 컨트롤러(Network Interface Controller. NIC)라고 한다.
  * 범용 고유 식별자(universally unique identifier. UUID)의 일종으로 기기마다 고유한 값을 부여해야 한다.
    * 그래서 NIC 제조업체는 하드웨어 제조 과정에서 MAC 주소를 기기에 새겨 넣음.
  * 첫 24비트는 OUI(organizationally unique identifier)로서 제조업체 식별코드로 IEEE가 제조사마다 고유한 번호를 할당해준다.
  * 나머지 24비트를 고유하게 할당하는 일은 제조업체 책임.

* 이더넷만 MAC 주소를 사용하는 것은 아니고, 와이파이나 블루투스 등 대부분의 IEEE 802 링크 계층 프로토콜에서 사용

* 이더넷 패킷 구성

  ![](images/internet_3.JPG)

  * 모든 이더넷 패킷은 0x55 7개에 0xD5 1개 총 8바이트의 16진수로 시작.
    * 이를 프리앰블(preamble)과 SFD(start frame delimiter)라 한다.
    * 밑단 하드웨어는 이러한 이진수 패턴을 체크하여 동기화를 맞추고 새 프레임을 받을 준비를 한다.
    * 프리앰블과 SFD는 보통 NIC 하드웨어가 걸러내며, 프레임을 구성하는 나머지 바이트 열을 이더넷 모듈에 넘겨 처리한다.
  * SFD 뒤에 따라붙는 6바이트는 프레임의 수신자로 설정된 기기의 MAC 주소를 나타냄
    * 브로드캐스트 주소를 의미하는 특수 MAC주소도 있음.
      * FF:FF:FF:FF:FF:FF로 나타내고 LAN 상 연결된 모든 호스트에 전달하고자 할 때 사용
  * 길이/종류 필드는 오버로드하여 길이나 종류 둘 중 하나로 사용.
    * 길이 필드로 사용하는 경우 프레임에 포함된 페이로드의 길이를 바이트 단위로 나타낸다.
    * 종류 필드로 사용하는 경우 이더타입(EtherType) 고유 식별자 값을 기록해 페이로드 내 데이터를 어떻게 해석해야 하는지 표시
    * 이더넷 모듈이 이 필드를 처리할 때 정확하게 해석할 수 있게, 이더넷 표준은 페이로드의 최대 길이를 1500바이트로 정의해두었다.
      * 이를 최대 전송 유닛(maximum transmission unit. MTU)라 하며, 한 번 전송에 최대한 담을 수 있는 데이터의 양을 뜻함.
      * 오늘날 이더넷 NIC는 1500바이트를 넘어서는 정보 프레임을 지원하기도 함.
      * 최대 9000바이트 까지 MTU를 갖게 되는데 이를 지원하는 NIC는 프레임 헤더에 특정 이더타입 값을 기록하여 밑단 하드웨어에서 수신된 데이터에 따라 프레임의 크기를 계산한다.
    * 이더넷 표준은 이더타입의 최솟값을 0x0600, 즉 10진수로 1536으로 정해둠.
      * 그러므로 길이/종류 필드 값이 1500이하인 경우에는 길이로 해석하고, 1536 이상인 경우에는 종류로 판단
  * 페이로드(payload)란 프레임에 담겨 전송되는 데이터 그 자체를 뜻한다.
    * 대개 원하는 호스트로 전달하고 싶은 네트워크 계층 패킷이 담겨 있다.
  * 프레임 체크 시퀀스(frame check sequence. FCS)
    * CRC32 (32-bit cyclic redundancy checksum) 값
    * 여러 값에 걸쳐 연산하여 얻은 체크섬 값
    * 연산에 포함되는 것은 발신자와 수신자 주소 각각, 길이/종류 필드, 페이로드, 그리고 패딩 값 등
    * 이더넷 하드웨어가 데이터 수신 시 이 값을 검사하여 전송된 데이터가 손상되었는지 판단
    * 만일 손상된 경우 프레임을 폐기해버림
      * 이더넷이 비록 데이터 전송을 보장해 주지는 못하지만 적어도 훼손된 값이 전달되지 않도록 최소한의 노력은 하는 셈

* 이더넷 패킷에 대한 요약

  * 네트워크 상 호스트 중 하나가 해당 프레임을 받으면 호스트가 프레임을 읽어보고 그 수신자가 마침 자신일 때, 길이/종류 필드의 값에 따라 페이로드에서 데이터를 꺼내어 처리한다.

* 초기엔 소규모 이더넷 네트워크에선 허브(hub)라는 장비로 여러 호스트를 한데 묶어 연결했다.

  * 이런식으로 연결된 네트워크에선 이더넷 패킷의 전기 신호가 네트워크상 모든 호스트에 전달되었는데, 그 패킷이 자기 것인지 아닌지 여부는 각 호스트가 스스로 판단해야 했다.
  * 네트워크 규모가 확장 될수록 이 같은 방식은 효율이 저하될 수 밖에 없었다.

* 오늘날 최신 네트워크에서는 스위치(switch)라는 장비로 여러 호스트에 연결한다.

  * 스위치의 포트에 호스트를 연결해 두면 스위치는 그 호스트의 MAC주소, 혹은 IP 도 같이 기억해 두었다가 그 주소로 패킷을 전달할 일이 있을 때, 연결된 여러 호스트에 일일이 보내지 않고도 해당 호스트를 특정하여 최단경로로 보낼 수 있다.



### 네트워크 계층

* 링크 계층만 있어도 주소가 부여된 호스트 사이에 데이터를 주고 받기에 충분할 것 같은데 어째서 TCP/IP 같은 부가적인 계층이 필요할까?
  * MAC 주소가 하드웨어에 각인되어 유연성이 떨어진다.
    * 웹서버를 하나 열었는데 인기를 끌어 매일 수천명의 사용자가 이더넷으로 방문한다고 가정.
    * 링크 계층만 써서 서비스를 하면 서버에 접속하기 위해 이더넷 NIC 장비의 MAC 주소를 사용자들이 알아야한다.
    * 어느날 과부하를 견디지 못하고 NIC 카드가 고장난 경우 새 NIC 카드를 장착해야 하는데 새 카드의 MAC 주소는 이전과 달라지기 때문에 사용자는 더이상 이전 주소로 접속할 수 없게 된다.
    * 따라서 쉽게 설정할 수 있는 주소 체계가 MAC 주소 위에 병행하여 필요하다.
  * 링크 계층으론 인터넷을 보다 작은 네트워크망으로 나눌 수 없다.
    * 전체 인터넷이 링크 계층으로만 되어 있다고 하면 모든 컴퓨터가 단일망에 연결되어 있어야 한다.
    * 이더넷에서는 각 프레임을 네트워크상 모든 호스트에 전달해야하고, 전송자가 애초 의도한 수신자가 바로 자신인지 여부는 호스트 스스로 판단해야 한다.
    * 프레임 하나하나를 보낼 때마다 지구상 연결된 모든 호스트로 일일이 전달해야 한다.
    * 네트워크망을 지역마다 서로 다른 보안 영역으로 구분해 둘 수단이 없다.
    * 같은 사무실 내 호스트에서만 메시지를 브로드캐스트하거나 집 안에 있는 컴퓨터 사이에서만 파일 공유할 수 있는 수단이 없다.
  * 링크 계층에는 한 종류의 링크 프로토콜을 그와 다른 링크 프로토콜로 번역하는 방법이 정의 되어 있지 않다.
    * 여러 종류의 물리 계층과 링크 계층 프로토콜을 두는 까닭은 바로 서로 상이한 네트워크 사이에서 용도에 가장 알맞은 최적의 구현을 각자 선택하게끔 하자는 근본 철학에서 비롯된다.
    * 그러므로 링크 계층 위에 별도의 주소체계를 두어 하나의 링크 프로토콜과 다른 링크 프로토콜이 서로 통신할 방법을 규정할 필요가 있다.
* 네트워크 계층의 역할은 링크 계층 위에 논리 주소 체계 인프라를 구축하는 것.
  * 주소 걱정 없이 쉽게 호스트 하드웨어를 교체할 수 있다.
  * 여러 호스트를 그룹으로 묶어 서브네트워크로 격리할 수 있다.
  * 멀리 떨어진 서브네트워크 사이에 링크 계층 프로토콜이나 물리적 매체가 각기 다르더라도 서로 통신할 수 있다.



#### IPv4

* 오늘날 네트워크 계층에 필요한 기능을 구현하는데 가장 널리 이용되는 프로토콜.
* 논리 주소 체계로 각 호스트마다 개별적인 주소를 부여
* 서브넷 체계로 주소 공간의 논리적 부분집합을 나누어 물리적 서브네트워크를 정의하는데 사용
* 라우팅 체계로 서브넷 사이에서 데이터를 서로 전달



##### IP 주소와 패킷 구조

* IPv4의 핵심은 바로 IP 주소.

* 인터넷 상 호스트마다 고유한 IP 주소를 부여해 두면, 발신 호스트가 패킷을 보낼 때 패킷 헤더에 목적 호스트의 IP 주소를 기록하기만 하면 된다.

* 패킷에는 우선 헤더 자리를 마련해 네트워크 계층 기능에 필요한 데이터를 담아두고 그 뒤에 윗단 계층의 데이터를 전송할 페이로드가 붙는다.

  ![](images/internet_4.JPG)

  * 버전(4비트) : 이 패킷이 지원하는 IP 종류를 표시. 
    * Ipv4라면 이 숫자는 4가 된다.
  * 헤더길이(4비트) : 헤더의 길이를 32비트 워드로 표시.
    * IP 헤더 뒷부분에 옵션 필드가 여럿 붙을 수 있으므로 헤더의 길이는 가변적
    * 길이 필드에 정확히 어디서 헤더가 끝나고 이어 포장된 실제 데이터가 시작되는지 나타내주어야 한다.
  * 서비스 종류(8비트) : 혼잡 제어나 서비스 식별자 등 다양한 용도로 사용.
  * 패킷 길이(16비트) : 전체 패킷의 길이를 바이트 단위로 표시
    * 길이는 헤더와 페이로드를 더한 것.
    * 16비트로 나타낼 수 있는 최대 숫자 65535(바이트)가 최대 패킷의 길이.
    * IP 헤더의 최소 길이는 20바이트이므로 Ipv4 패킷에서 페이로드가 담을 수 있는 최대 길이는 65515 바이트
  * 분열 식별자(16비트), 분열 플래그(3비트), 분열 오프셋(13비트) : 분열된, 즉 조각난 패킷을 다시 조립하는데 사용
  * TTL(time to live)(8비트) : 패킷을 전달할 수 있는 횟수 제한
  * 프로토콜(8비트) : 페이로드 내용을 해석하는 데 어떤 프로토콜을 써야 하는지 나타낸다.
    * 윗단 계층이 데이터를 어떻게 다루는지 나타낸다는 점에서 이더넷 프레임의 이더필드와 비슷
  * 헤더 체크섬(16비트) : IPv4 헤더의 무결성을 검증하는데 사용하는 체크섬을 기록.
    * 헤더 부분만 계산해 둔 것임에 유의
    * 페이로드의 무결성을 검증하는 것은 윗단 계층의 몫
    * 링크 계층 프로토콜에서 이미 체크섬으로 프레임 전체의 무결성 검사를 하는 경우(예를 들어 이더넷헤더의 FCS 필드)가 많기 때문에 불필요한 편.
  * 발신지 주소(32비트), 목적지 주소(32비트) : 패킷 발신지와 목적지의 IP 주소
    * 목적지의 경우 특수 주소값을 쓰면 여러 호스트로 동시에 패킷을 보낼 수 있다.




#### 직접 라우팅과 주소 결정 프로토콜(ARP)

* 서로 다른 링크 계층 프로토콜로 연결된 네트워크 사이에 IPv4로 어떻게 패킷을 전달하는지 이해하려면, 먼저 단일 링크 계층 프로토콜의 단일 네트워크에서 패킷이 전달되는 방식부터 이해해야한다.

* IPv4 프로토콜은 IP 주소로 패킷의 목적지를 지정.

* 링크 계층이 패킷을 전달하게 하려면 먼저 IP 주소를 링크 계층이 이해할 수 있는 주소 형태로 바꿔 프레임에 포함해주어야 한다.

* IP주소는 링크 계층이 아닌 네트워크 계층의 개념이기 때문에 IP 주소만으로는 이더넷 모듈을 통해 패킷을 전달할 수 없다.

* 링크 계층은 IP 주소를 이에 대응하는 MAC 주소로 변환하기 위해 주소 결정 프로토콜(address resolution protocol. ARP)를 사용한다.

  * ARP는 기술적으로는 링크 계층 주소를 직접 사용하는 링크 계층 프로토콜로서 네트워크 계층이 제공하는 라우팅을 필요로하지 않는다. 
  * 그렇지만 IP주소를 포함하는 등 네트워크 계층의 추상화를 침범하는 부분이 있으므로 전적으로 링크 계층 프로토콜로만 보기보다는 두 계층 사이의 다리 역할을 한다고 이해하면 좋다.

* ARP 구성

  1. NIC가 어느 MAC 주소에 대응되는지 질의하는 패킷 구조

  2. 짝을 이루는 여러 NIC와 MAC 주소 쌍을 정리해둔 표

     | IP Address | MAC Address       |
     | ---------- | ----------------- |
     | 18.19.0.1  | 01:01:01:00:00:10 |
     | 18.19.0.3  | 01:01:01:00:00:30 |



#####  ARP 절차

1. IP를 구현한 모듈이 링크 계층을 거쳐 어떤 호스트에 패킷을 보내고자 할 때, 먼저 수신자의 IP 주소에 대응하는 MAC 주소를 ARP 테이블에서 찾아본다.

2. 테이블에서 MAC 주소를 찾았다면 IP 모듈은 해당 MAC 주소를 포함한 링크 계층 프레임을 만들어 이를 링크 계층 모듈에 전달하여 발신한다.

3. 테이블에서 찾지 못한 경우 ARP 모듈이 링크 계층 네트워크에서 도달 가능한 모든 호스트에 아래와 같은 구조의 ARP 패킷을 발신하여 올바른 MAC 주소를 찾고자 시도하게 된다.

   ![](images/internet_5.JPG)

   * 하드웨어 종류(16비트) : 링크 계층이 호스트된 하드웨어 종류를 정의
     * 이더넷의 경우 1
   * 프로토콜 종류(16비트) : 네트워크 계층 프로토콜의 이더타입 값과 일치
     * IPv4라면 0x0800
   * 하드웨어 주소 길이(8비트) : 링크 계층 하드웨어 주소의 길이를 바이트로 나타냄
     * 대부분의 경우 MAC 주소는 6바이트
   * 프로토콜 주소 길이(8비트) : 네트워크 계층 논리 주소의 바이트 길이
     * IPv4의 IP 주소 길이는 4바이트
   * 오퍼레이션(16비트) : 1 또는 2의 값. 이 패킷이 정보 요청인지(1) 아니면 응답인지(2)를 지정
   * 발신지 하드웨어 주소(가변길이), 발신지 프로토콜 주소(가변길이) : 각각 패킷 발신지의 하드웨어 주소 및 네트워크 계층 주소를 나타냄
     * 이들 주소의 길이는 패킷 앞부분에 명시된 길이 필드와 일치해야한다.
   * 목적지 하드웨어 주소(가변길이), 목적지 프로토콜 주소(가변길이) : 각각 패킷 목적지의 하드웨어 주소 및 네트워크 계층 주소를 나타냄
     * 주소 질의를 요청하는 경우 목적지 하드웨어 주소는 알수 없는 상태이므로 패킷을 받는 측에선 이 내용을 무시함

4. 3번의 과정을 세분화

   1. 호스트 A가 B의 MAC 주소를 모르는 경우 ARP 요청 패킷을 만드는데, 오퍼레이션 필드는 1로, 발신지 프로토콜 주소 필드는 18.19.0.1로 발신지 하드웨어 필드는 01:01:01:00:00:10, 목적지 프로토콜 주소 필드는 18.19.0.2로 각각 설정
   2. 이 패킷을 이더넷 프레임에 감싸 이더넷 브로드캐스트 주소 FF:FF:FF:FF:FF:FF로 발신
      * 브로드캐스트 주소를 사용하면 네트워크 상 모든 호스트가 이 프레임을 받아 살펴보게된다.
   3. 호스트 C는 패킷을 받아도 응답하지 않는다.
      * IP 주소가 패킷상 목적지 프로토콜의 주소와 다르기 때문
   4. 호스트 B는 IP가 일치하므로 자신의 ARP 패킷을 하나 만들어 응답
      * 자기 주소를 발신지로, 호스트 A의 주소를 목적지로
   5. 호스트 A가 패킷을 받으면 새로 받은 주소로 ARP 테이블의 호스트 B에 대한 MAC 주소를 갱신
   6. 이를 기다리던 IP 패킷을 이더넷 프레임에 포함하여 호스트 B의 MAC 주소로 전송

   * Note
     * 호스트 A가 ARP 요청을 네트워크상 모든 호스트에 처음 브로드캐스트할 때, 호스트 A 자신의 MAC주소와 IP 주소를 포함해서 보낸다.
     * 이렇게 하면 네트워크에 연결된 다른 호스트들이 호스트 A의 정보로 미리 ARP 테이블을 갱신해둘 수 있다. 
     * 아직은 호스트 A의 정보가 필요 없다고 해도, 미리 갱신해두면 나중에 통신할 필요가 생겼을 떄 ARP 요청부터 보내지 않아도 되므로 요긴하다.
     * 악성 호스트가 모든 IP를 자기 것인양 조작한 ARP 패킷을 뿌릴 수 있다.
     * ARP 정보가 검증된 것인지 확인할 방도가 없다면 스위치 장비가 의도치 않게 모든 패킷을 악성 호스트에 전달해 바치는 결과가 나타날 수 있다.
     * 패킷을 훔쳐보는데 그치지 않고 전달되어야 할 패킷이 전달되지 못하여 네트워크 전체의 트래픽이 혼란에 빠지게 될 수 있다.



#### 서브넷과 간접 라우팅

* 두개의 큰 회사(알파와 브라보)가 있다고 가정 (각각 100대의 호스트를 가지고 있음)

  * 각 회사는 대규모 내부망을 구축
  * 양 사의 네트워크를 서로 연결하여 메시지를 주고 받고자 함
  * 이더넷 케이블을 링크 계층 네트워크에 연결하는 경우
    * 이더넷 패킷은 네트워크상 모든 호스트를 거쳐야 함
    * 기존의 100대의 호스트에 전달되던 이더넷 환경에서 다른 회사의 네트워크에 연결되면 200대의 호스트로 전달됨. (트래픽 두배 증가)
    * 특정 호스트에만 전달되면 될 패킷이 전체 호스트에 전달되므로 보안상으로도 문제가 있음.
  * 링크 계층 수준에서 직접 연결되지 않은 호스트 사이에서도 서로 패킷을 주고받을 수 있게 네트워크 계층에서 라우팅할 필요가 있음.

* 두 회사의 네트워크 계층 연결

  ![](images/internet_6.JPG)

  * 호스트 R은 라우터라 불리는 특수 형태의 호스트
  * 라우터 한대에 NIC가 여러개 장착됨
  * 각 NIC마다 고유 IP 주소가 배정
  * 네트워크 알파의 모든 IP 주소의 공통 접두사는 18.19.100
  * 네트워크 브라보의 모든 IP 주소의 공통 접두사는 18.19.200
  * 서브넷 마스크(subnet mask)는 32비트 숫자로서, IP 주소와 동일하게 숫자 네 개를 마침표로 구분
    * 어느 두 호스트의 IP주소를 각각 서브넷 마스크와 비트 AND 연산하여 그 결과가 같으면 두 호스트는 같은 서브넷에 속함.
    * 브로드캐스트 주소는 네트워크 주소상 서브넷 마스크 영역 외의 비트를 모두 1로 한값.
      * 18.19.100.1의 서브넷이 255.255.255.0이라면 가용 비트는 맨 뒷자리 8비트이므로 8비트가 모두 1이되면 255가 됨.
      * 즉, 18.19.100.255가 브로드캐스트 주소가 된다.
  * CIDR(classless inter-domain routing) 표기법
    * 서브넷 마스크를 이진수로 쓰면 1이 n개 나온 뒤 0이 (32-n)개 붙는 형식
      * 255.255.255.0이면 1이 24개, 0이 8개.
      * 32-24(1개수) = 8(0개수)
    * 서브넷을 표기할 때 먼저 네트워크 주소를 쓰고 슬래시(/)로 구분한 뒤 서브넷 마스크의 1인 비트 개수를 적는 식
    * 위 예제의 IP주소를 CIDR로 표기하면 1의 개수가 24개이므로 18.19.100.0/24 

* 각 호스트의 IP 모듈은 라우팅 테이블을 보유하여 서브넷 간 패킷 전달에 이용

  * 원격 호스트에 IP 패킷을 보내도록 어떤 호스트의 IPv4 모듈에 요청하면 먼저 IP 모듈은 ARP 테이블을 써서 직접 라우팅할지, 아니면 간접 라우팅할지부터 결정해야 한다.

  * 이를 위해 라우팅 테이블을 참조

  * 라우팅 테이블엔 도달 가능한 목적지 서브넷마다 패킷을 어떻게 전달할지에 대한 정보가 한 줄씩 기록되어있다.

    * 호스트 A1의 라우팅 테이블

      | 행 번호 | 목적지 서브넷        | 게이트웨이       | NIC                |
      | ---- | -------------- | ----------- | ------------------ |
      | 1    | 18.19.100.0/24 |             | NIC 0(18.19.100.2) |
      | 2    | 18.19.200.0/24 | 18.19.100.1 | NIC 0(18.19.100.2) |

    * 호스트 B1의 라우팅 테이블

      | 행 번호 | 목적지 서브넷        | 게이트웨이       | NIC                |
      | ---- | -------------- | ----------- | ------------------ |
      | 1    | 18.19.200.0/24 |             | NIC 0(18.19.200.2) |
      | 2    | 18.19.100.0/24 | 18.19.100.1 | NIC 0(18.19.200.2) |

    * 호스트 R의 라우팅 테이블

      | 행 번호 | 목적지 서브넷        | 게이트웨이       | NIC                |
      | ---- | -------------- | ----------- | ------------------ |
      | 1    | 18.19.100.0/24 |             | NIC 0(18.19.100.1) |
      | 2    | 18.19.200.0/24 | 18.19.100.1 | NIC 1(18.19.200.1) |

  * 목적지 서브넷 열은 대상 IP 주소가 포함된 서브넷을 가리킴

  * 게이트웨이 열은 다른 서브넷의 링크 계층으로 패킷을 전달하기 위해 거쳐야할 현재 서브넷상 다음 호스트의 IP 주소를 가리킴

  * 게이트웨이 호스트는 직접 라우팅으로 도달 가능해야 한다.

    * 게이트웨이 란이 비어있으면 목적지 서브넷 전체가 직접 라우팅으로 도달 가능하다는 뜻으로 링크 계층으로 직접 래킷을 보낼 수 있다.

  * NIC 열은 패킷을 전달하는 데 사용할 NIC가 어느 것인지 가리킴

* 18.19.100.2에 위치한 호스트 A1이 패킷 18.19.200.2의 호스트 B1에 전달할 때 다음 과정을 거친다.

  1. 호스트 A1이 발신자 주소 18.19.100.2, 수신자 주소 18.19.200.2로 IP 패킷을 만든다.
  2. 호스트 A1의 IP 모듈은 라우팅 테이블을 한 줄씩 위에서 아래로 훑어가다 IP 주소 18.19.200.2를 포함하는 목적지 서브넷 항목 중 첫번째 것을 찾는다.
     * 위 표에서 두번째 행이 찾아짐
  3. 제 2행에 등록된 게이트웨이 주소는 18.19.100.1이다.
     * 호스트 A1은 ARP와 이더넷 모듈을 이용해 패킷을 이더넷 프레임으로 꾸려 18.19.100.1에 해당하는 MAC 주소를 가진 호스트로 발신한다.
     * 이 패킷은 곧 호스트 R에 도착
  4. 호스트 R의 NIC 0번, 곧 IP 주소가 18.19.100.1인 이더넷 모듈은 프레임을 받아 그 페이로드가 IP 패킷임을 감지하고 IP 모듈에 올려보낸다.
  5. 호스트 R의 IP모듈은 패킷 주소가 18.19.200.2인 것을 확인하고 해당 IP로 패킷 전달을 시도한다.
  6. 호스트 R의 IP 모듈은 18.19.200.2를 포함하는 서브넷 항목을 라우팅 테이블에서 찾는다.
     * 위 표에서 2행에 해당.
  7. 2행엔 게이트웨이가 없으므로 이 서브넷은 직접 도달 가능
     * NIC 칼럼이 IP주소 18.19.200.1인 NIC 1을 가리킴
     * 이 NIC는 예시로 들었던 네트워크 브라보에 연결되어 있음.
  8. 호스트 R의 IP 모듈은 NIC 1에서 구동 중인 이더넷 모듈에 패킷을 넘겨준다. 
     * IP 모듈은 ARP와 이더넷 모듈을 이용해 패킷을 이더넷 프레임으로 꾸려 IP 주소 18.19.200.2에 해당하는 MAC 주소를 가진 호스트로 발신
  9. 호스트 B1의 이더넷 모듈이 프레임을 받아 그 페이로드가 IP 패킷임을 감지하고 IP 모듈에 올려보낸다.
  10. 호스트 B1의 IP 모듈은 수신자 IP 주소가 자기 것임을 확인
    * 상위 계층에서 계속 처리할 수 있게 페이로드의 내용을 윗단 계층으로 올려보낸다.

* 내부 네트워크에서 인터넷으로 패킷을 보내려면 어떻게 해야 할까?

  * 인터넷 서비스 공급자(internet service provider, ISP)로부터 공인 IP와 게이트웨이를 제공받아야 한다.

  * ISP로부터 18.181.0.29, 게이트웨이 18.181.0.1을 제공 받았다고 가정

    ![](images/internet_7.JPG)

    - 인터넷 접근이 가능한 호스트 A1의 라우팅 테이블

      | 행 번호 | 목적지 서브넷        | 게이트웨이       | NIC                |
      | ---- | -------------- | ----------- | ------------------ |
      | 1    | 18.19.100.0/24 |             | NIC 0(18.19.100.2) |
      | 2    | 18.19.200.0/24 | 18.19.100.1 | NIC 0(18.19.100.2) |
      | 3    | 0.0.0.0/0      | 18.19.100.1 | NIC 0(18.19.100.2) |

    - 인터넷 접근이 가능한 호스트 B1의 라우팅 테이블

      | 행 번호 | 목적지 서브넷        | 게이트웨이       | NIC                |
      | ---- | -------------- | ----------- | ------------------ |
      | 1    | 18.19.200.0/24 |             | NIC 0(18.19.200.2) |
      | 2    | 18.19.100.0/24 | 18.19.200.1 | NIC 0(18.19.200.2) |
      | 3    | 0.0.0.0/0      | 18.19.200.1 | NIC 0(18.19.200.2) |

    - 인터넷 접근이 가능한 호스트 R의 라우팅 테이블

      | 행 번호 | 목적지 서브넷        | 게이트웨이       | NIC                |
      | ---- | -------------- | ----------- | ------------------ |
      | 1    | 18.19.100.0/24 |             | NIC 0(18.19.100.1) |
      | 2    | 18.19.200.0/24 | 18.19.100.1 | NIC 1(18.19.200.1) |
      | 3    | 18.181.0.0./24 | 18.181.0.1  | NIC 2(18.181.0.29) |
      | 4    | 0.0.0.0/0      | 18.181.0.1  | NIC 2(18.181.0.29) |

  * 목적지 서브넷 주소 0.0.0.0/0은 기본 주소(default address)라 하는데, 모든 IP가 이 서브넷에 포함되기 때문

    * 호스트 R이 패킷을 받았는데 그 대상 주소가 1~3열 어느것에도 해당하지 않는 경우라면 마지막의 기본 주소에는 항상 대응이 된다.
    * 해당 패킷은 새로 장착한 NIC를 거쳐 ISP의 게이트웨이로 전달되며, 거기서 다른 여러 게이트웨이를 잇는 경로를 거쳐 패킷이 원래 의도한 목적지에 언젠가 도착할 수 있을 것이다.
    * 호스트 A1과 B1에도 인터넷 패킷을 호스트 R로 전달하게끔 기본 주소를 새 항목으로 추가해두었기 떄문에 인터넷용 패킷을 호스트 R을 거쳐 ISP로 라우팅할 수 있다.

* 게이트웨이가 패킷을 받아 전달할 때마다 IPv4 헤더의 TTL 필드 값이 하나씩 차감된다.

  * TTL 값이 0이되면 패킷이 어디에 체류 중이었건 상관 없이 마지막으로 차감했던 호스트의 IP 모듈이 패킷을 폐기한다.
  * 반복 순환되도록 라우팅된 경로가 있으면 해당 패킷이 영원히 인터넷을 떠돌아다니게 되기 때문에 이를 방지하기 위해서 TTL이 필요하다.
  * TTL 값을 변경하면 헤더 체크섬도 다시 계산해야하는데, 이 때문에 호스트가 패킷을 처리하고 전달하는데 약간의 지체가 발생한다.

* TTL이 0이 되는 것 외에도 패킷이 누락되는 경우가 있다.

  * 많은 양의 패킷이 라우터의 NIC에 소화할 수 없을 정도로 쏟아져 들어오면 NIC가 패킷을 그냥 무시해버릴 수도 있다.
  * NIC가 여러 개 장착된 라우터에 패킷이 들어오는데 NIC 중 하나가 이들 패킷 전부를 외부로 전달하여야 하는 경우, 그 NIC가 처리를 감당할 수 있을 정도로 빠르지 않다면 패킷 중 일부가 누락될 수 있다.

* 여러가지 누락될 수 있는 경우로 인해 IPv4를 포함하여 네트워크 계층의 모든 프로토콜은 비신뢰성 프로토콜로 취급한다.

  * 패킷이 도착한다 해도 원래 보낸 순서대로 도착한다는 보장도 없고, 단 한번만 전달된다는 보장도 없다. 
  * 네트워크가 혼잡하다보면 라우터가 패킷 하나는 이쪽 경로로 라우팅하고 같은 목적지의 다른 패킷은 다른 쪽 경로로 라우팅할 수 있다.
    * 경로는 저마다 길이가 다를 것이고 그러다 보니 나중에 보낸 패킷이 먼저 도착할 수도 있다.
  * 어떤 경우엔 패킷이 여러 경로로 동시에 전달될 수도 있는데, 그 중 하나가 먼저 도착하고 나머지가 또 다시 도착하는 경우도 생긴다.



##### 중요 IP 주소

* 127.0.0.1
  * 루프백(loopback) 또는 로컬 호스트 주소(localhost address)
  * 패킷을 127.0.0.1로 보내려하면 IP 모듈은 외부로 패킷을 보내지 않는다.
  * 대신 이 패킷을 고스란히 다시 받은 것처럼 만들어 윗단 계층이 처리하게 올려보낸다.
* 255.255.255.255
  * 제로 네트워크 브로드캐스트 주소(zero network broadcast address)
  * 패킷을 현재 로컬 링크 계층 네트워크의 모든 호스트로 브로드캐스트하지만, 라우터를 거쳐 외부로 나가지는 못하게 한다.



#### 패킷 분열

