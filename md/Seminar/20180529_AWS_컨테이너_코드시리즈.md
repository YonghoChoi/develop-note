# Docker

* 이미지는 RO
  * 이미지를 링킹하여 Writable하게 한 것이 컨테이너
* Write overhead
  * 레이어드 방식이기 떄문에 파일 변경이 발생하면 변경이 발생한 지점을 찾기 위해 각 레이어로 상위부터 찾아내려감
  * 일반 파일시스템은 그냥 변경된 파일을 수정. 이에 비해 오버헤드가 발생함
  * 파일 변조가 많아 일어나는 부분은 볼륨으로 사용
* VM이 isolation이 가장 높음. 이에 비해 컨테이너는 빈약하여 보안에 취약한것 아닌가 하는 우려가 있음
  * docker도 충분히 보안적인 부분과 isolation 제공
* Endtrypoint : 컨테이너 구동 시 실행되는 명령을 Dockerfile에 강제. 사용자가 오버라이드 불가능
* CMD : 컨테이너 구동 시 실행 명령을 사용자가 오버라이드 가능
* dockerfile의 각 명령들마다 이미지가 생성됨
  * 불필요한 이미지는 제거됨
  * docker history를 통해 내역 확인 가능



# ECS

* EKS 늦어도 7월 중에 나올 예정
* ECS 내 서비스들에서 올라가는 컨테이너들은 종료되면 데이터가 전부 날라감 (휘발성)
  * 대안으로 EKS 사용 시 StateSet 사용
  * 대안으로 S3, EFS, RDS 사용
* ECS와 EC2의 스케일링은 별도
  * ECS의 스케일링은 컨테이너에 대한 스케일링
  * EC2는 인스턴스 단위의 스케일링
  * Fagate는 알아서 스케일링
* ECS는 오케스트레이션 툴이기 때문에 컨테이너 조작에 대한 부분 보다는 메타데이터를 활용한 오케스트레이션 관리에 집중
  * 메타데이터 관리는 작업이라는 단위를 최소로하여 관리됨
* 클라우드 와치 매트릭 제공
* 태스크는 컨테이너들의 그룹, 이 그룹들이 몇개가 뜰것인지 어떻게 오케스케일링 될 것인지에 대한 설정은 서비스에서 함
  * 문제가 생기면 서비스가 감지해서 정상의 상태로 유지
  * 쿠버네티스의 팟과 서비스와 비슷
* ECS 호스트들을 관리할 에이전트가 각 EC2에 설치됨
  * 명령 수행 및 상태 관리
* 최적화 AMI를 사용하는 것이 좋음
* ECS의 로드밸런싱은 ALB 사용



* 작업 정의


  * container Definition
    * essential이 설정된 컨테이너로 헬스 체크
    * 하드리밋을 초과하면 컨테이너를 터미네이트
  * Task에 정의한 것은 동일한 호스트에 동작
    * 서비스 내에 포함시켜야 태스크 단위로 각 호스트들에 배포
* ALB 
* PrivateLink Interface



## 코드 시리즈

* buildspec을 통해 컨테이너 띄울 떄 만들어진 이미지는 유지 안됨
  * 사용 후 제거됨
  * 그래서 시간이 올래걸리는 단점이 있음​