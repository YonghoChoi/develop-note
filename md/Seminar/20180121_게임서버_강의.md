# 게임 서버 강의 2주차

* Linux 환경의 OS에서는 limit 설정을 풀어야 하는 경우가 많음
* 보드류 게임은 보통 클라이언트 개발자가 서버까지 다 함
* 캐쥬얼 게임은 우리나라 기준으로 MMORPG가 아닌 게임들을 주로 이야기함
  * 보드게임과 MMORPG의 중간 정도의 난이도/기술력
* MMORPG는 작은 회사에서 만들더라도 하이 레벨의 기술력이 필요
  * 높은 성능을 위해 기능 별로 서버 분산



## OS별 IO

* Windows는 IOCP
* Linux는 epoll

여기서 IOCP만 비동기, epoll은 비동기는 아니고 select 를 개선한 정도



## 스레드

* Boost라이브러리의 Thread 라이브러리가 C++11의 표준으로 들어감
* 과도한 스레드는 성능 저하
  * 락을 최소화 하는 스레드 구조로 가야함
  * 개발 당시에는 문제가 잘 안터짐
  * Thread Checker, Thread Profiler 와 같은 툴을 사용하여 체크
  * 멀티 스레드보다 원스레드로 관리하는 것이 좋을 수 있음



## 데이터베이스

* MS SQL 2012부터 코어단위로 가격 책정이 들어가서 엄청 비싸짐
  * MS SQL은 ODBC 많이 씀
* 게임쪽은 카산드라 거의 안씀
* 레디스, 몽고디비 많이 씀



## P2P

* 일반 적인 한국 가정에서 쓰는 대부분은 Full Cone NAT
  * 그래서 한국은 P2P가 85% 정도 거의 다 됨
* Symmetric NAT는 중국에서 많이 씀
  * P2P 안될 소지가 많음
* 모바일은 P2P 보다는 릴레이 서버를 둬야함



## 길찾기

* 내비메쉬가 메모리가 다 올라와야 길찾기 알고리즘이 가능
  * 서버에 올려야 하기 때문에 메모리를 적게 먹도록 뽑는게 중요



## 툴

* IDE
  * 비쥬얼 스튜디오로 리눅스 C++ 프로그래밍 하고 싶으면 리눅스용 서버 필요
    * 원격으로 접속해서 디버깅



## 비정상 종료

* 덤프파일을 분석할 수 있는 시스템을 미리 구축해놓는 것이 필요



## 관리툴

* 타 팀에 제공 해야할 툴 제작
  * 데이터 관련
    * 데이터 잘못 입력하는 실수 방지
* 서버 관리 툴
  * 서버 어플 on/off 및 모니터링
  * 디비 조작



## 데이터 분리

* 데이터만 바꾸면 반영될 수 있도록 구조 설계



## 게임 개발 흐름

* 서버 구조 설계할 떄는 게임에 대한 방향성이 나와 있어야 함
  * 방향성에 맞춰서 아키텍처 설계



## 치트

* 라이브 환경에서는 아예 코드에 접근하지 못하도록 구성
* 치트 쓰는 유저에게 별도의 표시를 해서 다른 사용자가 봤을 때 버그로 혼동하지 않도록 하는 것이 좋음



## 서버 코드

* Linger 옵션 사용하면 graceful close 하지 않고 바로 close 시킴
  * 게임 서버에서는 성능을 위해 중요하지 않은 데이터 통신에서 많이 사용됨
* 추천 스레드 수
  * 코어수에 맞추는 것이 좋음
  * 스레드 컨텍스트 수 * 2 + 1
    * MS에서 권장하는 방식



## 동기화

* 크리티컬 섹션 사용 시 예외가 발생하면 좀비 스레드가 되어버림
  * 아무도 접근 못함
  * 뮤텍스는 예외 발생 시 락을 해제하기 때문에 많이 사용



## 하드웨어의 발전

* c10k 문제는 최근 하드웨어 성능이 너무 좋아져서 전과 같지 않음
* 스레드 하나 생성하면 윈도우 기준 1mb의 메모리가 잡힘
* 예전과 다르게 CPU와 RAM이 좋아져서 전과 같은 컨텍스트 스위칭이나 메모리문제가 심각하게 발생하지는 않음
* 유저 마다 통신에서 스레드를 사용하지 않기 위해 IOCP나 epoll 사용
* 상황에 따라서 소켓 모델을 사용하면 됨



## 이벤트 주도 프로그래밍

* IOCP
  * 멀티 코어 사용
    * IOCP의 강점
* epoll
  * 멀티 코어를 사용하려면 별도 처리가 필요
* select
  * 수가 늘어날 수록 속도가 느려짐
  * 배열 사용
* 리눅스
  * select
  * poll
    * select와 거의 동일
  * epoll
    * 리눅스
  * kqueue
    * Free BSD
  * /dev/poll
    * 솔라리스
  * epoll, queue, /dev/poll은 발생한 이벤트에 따라 처리
  * select/poll은 요청 대기



## select

* 원스레드이기 때문에 데이터 처리과정이 긴 서비스에는 적합하지 못함
* 배열에 있는 값을 매번 검사해야함
* 유입되는 유저 수가 적을 경우에는 IOCP와 select의 성능차이가 크지 않음
  * 접속자 수 1000 이하는 거의 같음
* IOCP는 멀티 스레드 환경이기 때문에 select보다 구현 난이도가 높음
  * 유저수가 얼마 안되고 한 서버에 유입되는 유저 수가 적을 경우에는 IOCP 경험이 없다면, 또는 멀티 스레드 환경에 익숙하지 않다면 안정성을 위해 select를 선택하는 것이 바람직
* WSAAsyncSelect는 쓰지 않는 것이 좋음.
  * 언제 사라질지 모름
* WSA 붙은건 비추. 썩 좋은게 없음
* 비동기 IO 를 사용하는 경우는 기본적으로 넌블럭킹
* 멀티 스레드를 사용하기 전 고려해볼 것
  * 원스레드로 사용하면 안되는지
  * 멀티 프로세스로 사용하면 안되는지
  * 정 안되면 멀티스레드로
    * 멀티 스레드를 쓰는 경우 공유 객체는 최대한 줄이는 걸로
* 리눅스는 소켓 번호가 시퀀셜하게 부여됨
  * 윈도우는 랜덤
* ​

