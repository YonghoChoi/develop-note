* epoll은 synchronous I/O
  * AIO가 붙은 async도 지원하는데 파일쪽으로만 사용
  * AIO를 네트워크로 사용할 수도 있지만 성능이 더 나쁨
  * 기본적으로 멀티 스레드가 아님
  * 고성능을 내기 위해서는 스레드를 직접 생성해서 멀티 스레드로 만들어야함
* IOCP는 Asynchronous I/O
  * 무조건 멀티 스레드 사용해야함
* Reactor
  * 동기 방식
  * epoll
* Proactor
  * 비동기 방식
  * IOCP
* IOCP를 사용하면 스레드에 대한 관리를 커널에서 해줌
  * IO Completetion Queue : 완료된 이벤트들의 큐
  * Waiting Thread Queue : Release 스레드에 공간이 생길때까지 대기하는 스레드들
  * Release Thread List : 현재 활동하고 있는 스레드드들
  * Pause Thread List : Release에 있다가 lock에 걸려서 대기 상태에 빠진 스레드들 
    * Pause가 풀려서 다시 Release로 넘어갈때 이미 스레드 카운트가 다 차있더라도 일시적으로 가용 스레드 수를 늘려서 Release로 들어갈 수 있도록 함.
* Zero byte recv
  * Recv 버퍼 사이즈를 크게 잡을 수록 페이지 락이 발생하기 때문에 recv가 들어오지 않더라도 버퍼를 잡고 있어서 낭비가 발생
  * recv를 0으로 잡아서 버퍼는 잡지 않고 얼만큼의 데이터가 수신되었는지만 확인 후 recv를 한번 더 걸어서 받은 데이터 크기 만큼만 recv해서 페이지 락을 최소화
  * recv가 두번 발생하기 때문에 램 가격이 싸고 풍족한 현시점에서는 zero byte recv는 좋은 방법은 아님
  * 요즘은 커널도 많이 업글되어서 알아서 잘 관리해줌. 쓸데 없는 처리는 안하는 것이 좋음
* 패킷을 수신하면 커널의 버퍼에 데이터가 쌓이고 어플리케이션으로 복사해서 전달함
  * 복사 비용이 발생
  * SO_RCVBUF, SO_SENDBUF 크기를 0으로 하면 커널의 버퍼가 0이어서 곧바로 어플리케이션 버퍼로 데이터가 수신됨. 복사 비용이 발생하지 않음
  * 어플리케이션에서 병목이 생겨서 커널로 응답 전달이 느려지면 커널쪽에서는 recv 버퍼가 비어 있기 때문에 요청을 계속 받게 될 것이고, 어플리케이션과 커널의 상황이 달라져버리는 현상이 발생하게 됨
  * 이 설정도 안건드는 것이 좋음. 커널이 알아서 하도록 냅두는 것이 좋음..