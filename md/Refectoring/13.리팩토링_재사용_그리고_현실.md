# 13장 리팩토링, 재사용 그리고 현실

## 현실 검사

* 전형적인 학자의 딜레마(학자의 연구는 실제 사용되는 기술보다 앞서 있다).
* 객체지향 기술이 나온지 얼마 되지 않았을 때, 객체지향 기술을 사용하고 있는 프로젝트들은 초기 버전을 넘어서 진행된 경우가 거의 없었기 때문에 리팩토링이 필요한 상황을 거의 접하지 못하였기 때문이다.
* 개발자들에게 리팩토링이 절실하게 들리지 않는다.

## 왜 개발자들은 리팩토링을 꺼리는가?
* 개발자가 리팩토링을 하는 방법을 이해하지 못한다.
* 리팩토링이 장기적으로 이익이라면, 왜 지금 당장 노력을 기울여야 하는가? 장기적으로 개발자가 리팩토링의 이익을 챙길 그 프로젝트에 있지 않을 수도 있다.
* 코드를 리팩토링하는 것은 오버헤드다. 개발자가 해야 하는 일은 새로운 기능을 추가하는 것이다.
* 리팩토링은 기존 프로그램을 망칠 수 있다.

**위 네 가지는 모두 그럴듯한 이유들이다. 일부는 기술 관점에서의 문제이고 일부는 관리 관점에서의 문제이다. 이와 같은 문제가 해결되고 나서야 개발자들은 리팩토링을 고려할 것이다.**

## 어디를, 어떻게 리팩토링 해야 하는가?

* 개발자들이 그들의 코드를 리팩토링 해야 한다는 것을 확신하기 전에, 어느 부분을 어떻게 리팩토링 해야 하는지를 이해해야 한다.
* 하지만 이런 지식은 경험만을 통해서 얻을 수 있다.
* 자동화된 도구는 프로그램의 구조를 분석하고 구조를 향상시킬 수 있는 리팩토링 방법을 제시해 줄 수 있다.
* 하지만 도구가 프로그램을 구조적으로 분석해서 제시한 제안 중 일부만 유용할 것이다. 프로그래머로써 임무는 제안된 사항들 중 프로그램에 실제로 적용할 사항을 선택해서 고치는 것이다.
* 다른 모든 경우와 마찬가지로, 도구나 기술은 그것을 사용할 때에 도움이 된다. 프로그래머들은 그들의 코드를 리팩토링 할수록 코드를 더 잘 이해하게 될 것이다.

## C++ 프로그램에서의 리팩토링

* C\++는 정적 타입 검사(static type checking)와 같이 프로그램 분석과 리팩토링 작업을 단순하게 하는 여러 가지 특징들을 가지고 있다. 반면에 C++에서 허용되는 몇 가지 코딩 스타일은 프로그램을 리팩토링 하는 것을 어렵게 한다.

### 리팩토링을 지원하는 C++의 특징과 프로그래밍 스타일

* C++의 정적 타입 검사는 리팩토링을 하려는 부분과 관련된 코드를 찾는 것을 쉽게 만들어 준다.
* C++는 클래스 상속과 접근 권한(public, protected, private) 등의 특징을 가지고 있어 함수 이름이 변경되었을 때 관련된 부분을 찾는 것이 비교적 쉽다.
* C++에서는 함수들 중 하나의 이름이 변경되었을 때 어느 부분이 변경된 함수를 참조하고 있는지를 결정하는 것은 별로 어려운 일이 아니다.
* C++는 서브타이핑을 구현하기 위해서 서브클래스를 사용하기 때문에 변수나 함수를 상속계층에 따라 올리거나 내려서 변수나 함수의 범위를 일반화(generalize)하거나 특정화(specialize) 할 수 있다.
* 따라서 프로그램을 분석해서 리팩토링을 하는 과정이 상당히 직관적이다.
* 상속을 사용해서 일반화와 특정화 계층을 만들면 상속 계층 내에서 이 멤버들을 이동하는 리팩토링을 사용할 수 있기 때문에, 나중에 멤버 변수나 멤버 함수의 영역을 일반화 하거나 특정화 하는 것이 꽤 직관적이 된다.
* C++ 환경의 특징들은 리팩토링을 지원한다. 리팩토링을 하는 동안 버그가 생긴다면 종종 C++ 컴파일러는 에러를 발생시킨다. 또한 많은 C++ 소프트웨어 개발 환경은 교차 참조와 코드 브라우징 등의 강력한 기능을 제공한다.

### 리팩토링을 복잡하게(어렵게) 하는 C++의 특징과 프로그래밍 스타일

* 포인터나 캐스트 연산, sizeof(object)와 같은 C++ 언어 특징을 사용하는 프로그램은 리팩토링 하기가 어렵다. 포인터나 캐스트 연산은 aliasing을 만들고, 이는 리팩토링을 하려는 객체를 참조하는 모든 부분들을 찾기가 어렵도록 만든다.
* C++는 스몰토크나 자바와 비교해서 복잡한 언어이기 때문에, 리팩토링을 하는 것이 안전한지 검사하고 안전하다면 그 리팩토링을 실행하도록 지원하는 자동화된 도구에 유용한 프로그램 구조를 만드는 것이 훨씬 더 어렵다.
* C++는 컴파일 할 때 대부분의 참조를 결정하기 때문에 보통 프로그램을 리팩토링 하는 과정에서 변경한 부분이 어떻게 영향을 미치는지를 테스트 해보려면, 적어도 그 부분을 여러 번 컴파일 하고 링킹해야 한다.
* C++가 메타레벨(metalevel) 프로그램 분석과 변경을 지원하지 않는다.

### 단기적인 이점을 달성하기 위한 리팩토링

* 많은 면에서 리팩토링은 운동과 적당한 음식을 먹는 것과 같다.
* 좀더 운동하고 좀더 균형 있는 식사를 해야 한다는 것을 알고 있다.
* 이런 좋은 습관을 실천하지 않고도 지낼 수 있고, 어떤 경우에는 이런 습관을 실천하는 것과 실천하지 않는 것과의 차이가 없는 것처럼 보일 수도 있다.
* 우리는 항상 변명을 할 수 있다. 하지만 결국 손해 보는 것은 자기 자신이 된다.
* 일부는 좀더 정력적이 되고 유연성이 증대되고 자아 만족감이 높아지는 등 단기적인 잠점 때문에 운동과 균형 있는 식사를 하려고 할 것이다.
* 거의 대다수는 이런 단기적인 장점들이 매우 현실적이라는 것을 알고 있다.
* 전부는 아니지만 대부분의 사람들은 이런 좋은 습관을 가끔이라도 실천하려고 노력한다.
* 그러나 다른 사람들은 이런 좋은 습관을 실천하는 사람들이 가시적인 성과를 보기전까지는 이를 실천해야 한다는 결정을 내리지 않는다.
* 리팩토링은 단기적인 이점을 가져다 줄 수 있고, 소프트웨어를 쉽게 수정하고 유지보수 할 수 있도록 해준다.
* 리팩토링은 목적이라기 보다는 수단이다.
* 리팩토링은 프로그래머나 프로그래밍 팀이 그들의 소프트웨어를 개발하고 유지보수 하는 많은 방법 중에 일부이다.

### 리팩토링의 오버헤드 줄이기

* 리팩토링은 오버헤드 활동이다. 나는 새롭고, 수익을 가져오는 기능을 작성하기 위해 월급을 받는 것이다.

* 리팩토링을 빠르고 비교적 쉽게 하게 하는 도구와 기술이 이용 가능하다.
* 몇몇 객체지향 프로그래머에 의해 보고된 경험에 따르면, 리팩토링에서의 오버헤드는 소프트웨어 개발의 다른 단계에서 노력과 시간을 보상하고도 남는다는 것을 알 수 있다.
* 리팩토링이 처음에는 비록 조금 거추장스럽고 오버헤드처럼 보이겠지만, 소프트웨어 개발 과정의 한 부분이 되고 나면, 오버헤드라는 느낌은 없어지고 필수적이라고 느끼기 시작한다.
* 리팩토링은 개발 과정의 일부가 되었기 때문에 리팩토링을 하는 것이 오버헤드가 아니다.
* 리팩토링을 안전하게

* 안전성은 특히 큰 시스템을 개발하고 발전시키는 조직에 있어서 중요한 관심사이다.
* 안전하게 리팩토링할 수 있는 몇 가지 옵션.
	* 여러분의 코딩 능력을 믿어라.
	* 여러분이 놓친 에러들은 컴파일러가 발견할 것이라고 믿어라.
	* 여러분과 컴파일러가 놓친 에러를 테스트 스위트(test suite)가 발견할 것이라고 믿어라.
	* 여러분, 컴파일러, 테스트 스위트가 놓친 에러는 코드 검토(code review)에서 발견될 것이라고 믿어라.
* 모든 안전성 검사는 리팩토링 도구를 사용해서 행해질 수 있다. 프로그램을 리팩토링하려는 프로그래머는 단지 도구를 사용해서 그 코드를 검사하고, 만약 안전하다면 리팩토링을 실행한다.
* 리팩토링 도구를 적용하는 것이 프로그램을 컴파일하고 테스트하고 코드를 검토하는 과정에서 발견될지도 모르는 많은 에러들을 피하게 한다 할지라도, 프로그램을 컴파일하고 테스트하고 코드를 검토하는 것은 여전히 가치가 있다.

## 현실검사(재방문)

* 리팩토링을 하려는 부분이 여러 사람들이 담당하고 있는 각 부분에 흩어져 있다면 어떻게 할 것인가?
	* 어떤 경우에는 많은 전통적인 변화 관리 메커니즘이 적절하다.
	* 반면에 소프트웨어가 잘 디자인되고 리팩토링되었다면, 다양한 리팩토링을 적용한다 해도 코드 베이스의 일부분만 영향을 받도록 서브 시스템이 충분히 분리될 것이다.
* 다양한 버전의 코드가 있다면 어떻게 할 것인가?
	* 어떤 경우에 모든 버전에 대해서 리팩토링을 하는 것이 적절할 것이고 이 경우에 리팩토링을 적용하기 전에 모든 버전에 대해서 안전성 검사가 선행되어야 한다.
	* 반면에 어떤 경우에는 몇 가지 버전에 대해서만 리팩토링을 하는 것이 적절하고 이는 코드를 검사하고 리팩토링하는 프로세스를 간단하게 한다.