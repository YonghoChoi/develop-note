## 객체란?

* 객체 : 세상에 존재하는 모든 것은 사물, 즉 객체.
* 각각의 사물은 고유하다
* 사물은 속성을 갖는다.
  * 값으로 가질 수 있는 것
  * ex) 사람의 키, 몸무게 등
* 사물은 행위를 한다.
  * 무생물은 의인화 필요
* 객체를 인지할 때 우리는 분류(class) 한다.



## 클래스 vs 객체

* 객체 : 세상에 존재하는 유일무이한 사물

* 클래스 :  같은 속성들과 기능들을 가진 객체들을 총칭하는 개념

  * 사람 분류(class)
    * 사람 클래스의 인스턴스들 = 원빈, 현빈, 장동건 등등
    * 사람이라는 분류가 클래스, 원빈, 현빈과 같은 특정 인물(실체)이 인스턴스

* 붕어빵틀 vs 붕어빵 은 잘못된 개념

  * 클래스와 객체의 필요충분조건

    ```
    클래스 객체참조변수명 = new 클래스()
    ```

    * 붕어빵에 적용하면

      ```
      붕어빵틀 붕어빵 = new  붕어빵틀()
      ```

      풀어서 설명하면 붕어빵 틀을 하나 제작하여 붕어빵 틀 역할을 하는 붕어빵이라 이름지었다. -> 논리가 맞지 않음.

    * 여기서의 붕어빵틀은 클래스가 아니라 붕어빵이 팩토리이다.

  * 펭귄 뽀로로 = new 펭귄() -> 뽀로로는 펭귄이다. -> 논리적으로 적절함.

* 우리가 작성하는 코드는 기계를 위한 것이 아니다. 사람을 위한 것임. (실행 시에는 전부 기계어로 번역) 그러므로 사람이 보기 쉽게 논리에 맞게 작성 해야 한다.

* 결국 클래스와 객체는 유일무의한 분류인 class와 이를 실체화한 것을 객체라고 생각하면 된다.

* ​



## 객체지향의 4대 특성

* 캡슐화(Encapsulation)
  * 목적은 정보 은닉 (information Hiding)
    * private
    * getter, setter
* 상속 (Inheritance)
  * 목적은 재사용(reuse)
  * 상속은 오해를 불러일으킴. 상속 대신 확장 -> 그래서 자바에서는 keyword가 extends
* 추상화(Abstraction)
  * 추상화는 모델링이다.
  * 구체적인 것을 분해해서 관심 영역에 대한 특성만을 가지고 재조합 하는 것 = 모델링
* 다형성(Polymorphism)
  * overriding
  * overloading





## 추상화

* 구체적인 것을 분해해서 관심 영역에 대한 특성만을 가지고 재조합 하는 것

* 추상화의 안경을 쓰고 객체들을 통해 클래스를 모델링

  ![](images/java_1.png)

  * 사람을 표현하기 위해서는 위의 내용 말고도 표현해야할 내용들이 엄청나게 많다. 
  * 관심 영역, 즉 어플리케이션 경계(=도메인, =컨텍스트)를 설정하는 것이 중요하다.

  ![](images/java_2.png)

  * 병원 어플리케이션이라고 하면 사람은 환자다.
    * 시력, 몸무게, 혈액형 등의 정보가 필요.
    * 직업이나 연봉과 같은 정보는 필요 없음.
  * 은행 어플리케이션이라고 하면 사람은 고객이다.
    * 나이, 직업, 연봉 등의 정보가 필요.
    * 시력, 몸무게 혈액형 등의 정보는 필요 없음.

* 쥐를 가지고 예를 들어보자

  ![](images/java_3.png)

  위와 같이 쥐의 특성을 먼저 파악해본다. 그런 다음 어플리케이션의 경계를 설정하여 관심있는 특성들만 추려낸다. 이 때 툴이나 언어에 종속되지 않고 자유롭게 설계하는 것을 논리적 설계라 하고, 툴이나 언어에 의존적인 설계를 물리적 설계라고 한다. 아래와 같이 설계 할 수 있다.

  ![](images/java_4.png)

  결국 추상화라는 것은 모델링을 한다는 의미이고, 모델링은 클래스를 설계하는 것을 의미한다. 클래스를 설계할 떄 아래와 같은 사항들을 정의 해야 한다.

  * 클래스 설계
    * 클래스 멤버 (static) : 클래스 멤버 속성/메소드
    * 객체 멤버 : 객체 멤버 속성/메소드

  ​



## 상속(inheritance)

* OO의 상속은 계층이나 조직이 아니다.

![](images/java_5.png)

* OO의 상속은 확장이다. 그래서 자바에서는 inheritance 키워드가 없고 extends를 사용한다.
  * 계층도, 조직도가 아닌 분류도이다.

![](images/java_6.png)

* 고래는 포유류를 확장하는 개념, 포유류는 동물을 확장하는 개념.

![](images/java_7.png)

* 분류도의 위로 올라갈 수록 추상적. 아래로 내려 올 수록 구체적이다.

* 계층도, 조직도로 생각하면 is a 관계가 성립하지 않는다. 나는 아버지인가? 아버지는 할아버지인가? 논리적으로 성립되지 않는다. 하지만 분류도로 생각하면 논리에 맞다. 고래는 포유류이고, 포유류는 동물이다. 즉, 하위클래스는 상위클래스다. (LSP - 리스코프 치환 원칙)

* 동물이 최상위 클래스일까? 자바에서의 모든 클래스에 대해 최상위 클래스는 Object 클래스이다.

* 자바는 다중 상속을 지원하지 않는다. 다이아몬드 상속 문제 때문. 

  ![](images/java_8.png)
  * 인어는 사람과 물고기의 특성 일부를 가지고 있다. 여기서 수영을 하기 라는 행위를 하려하면 인어는 사람처럼 다리로 헤엄쳐야할지 물고기 처럼 지느러미로 헤엄을 쳐야할지 애매한 상황이 발생한다.  잘 사용하면 좋지만 문제가 발생할 소지가 있기 떄문에 자바에서는 다중상속을 허용하지 않는다.
  * 이를 위해 다이아 상속 문제를 일으키지 않는 인터페이스를 제공. 


* 상속은 재사용과 확장.
  * 하위 클래스를 생성하면 메모리에 상위클래스도 함께 적재된다.
* 상속은 is a 관례를 만족해야 한다. 하지만 분류의 관계에서는 is a 보다는 is a kind of 가 맞는 말.
* 포유류 is a 동물 이라고 하면 포유류는 객체가 된다. 하지만 포유류도 역시 분류. 그렇기 때문에 포유류는 동물의 한 종류이다 라고 하는 것이 더 나은 방법. 
  * 하위분류 is a kind of 상위분류, 객체 is a 상위분류.
* 상속의 목적은 재사용. 인터페이스의 목적은 구현 강제. 표준 준수
  * 객체 is able to 인터페이스
  * Serializable : 직렬화 할 수 있는
  * Cloneable : 복제 할 수 있는
  * Comparable : 비교할 수 있는
  * Runnable : 실행할 수 있는
* 인터페이스는 최소주의
* 상속은 재사용이기 떄문에 풍성할 수록 좋음.
  * 상위 클래스가 많은 것을 구현하고 있으면 하위 클래스는 구현할 것이 적어짐.
  * 그렇다고 무조건 공통된 기능을 상위클래스에 올리는 것은 클래스를 복잡하게 만들 수 있음. 논리에 맞게 역할에 맞게 구현.
  * 그래서 모델링이 중요
  * ​

