## 객체지향 프로그래밍

객체지향 프로그래밍에 대한 정의를 위키피디아에서 가져와보았습니다.  정의를 보면 객체 지향 프로그래밍은 컴퓨터 프로그래밍의 패러다임의 하나이다. 라고 되어 있습니다. 객체 지향이라는 것은 하나의 개념 적인 것이고 이 개념을 자바에서는 자바의 방식대로 구현해나가고 C#이나 C++과 같은 다른 언어에서도 언어의 특성에 따라 구현하고 있습니다. 그래서 같은 객체지향 프로그래밍 언어라고 하더라도 C++에서는 다중 상속을 지원하는 반면 자바에서는 복잡성을 제거하기 위해 다중상속을 허용하지 않고, 인터페이스를 통해 지원을 하고 있습니다. 

객체지향이라는 단어에서 보듯이 객체지향 프로그래밍은 객체들로 이루어져 있고 각각의 객체는 메시지를 주고 받고 데이터를 처리할 수 있습니다. 



## 객체

그러면 이 객체라는 것은 무엇일까요? 객체를 실세계에서 찾아보자면 세상에 존재하는 모든 사물이 객체입니다. 반면 자바에서의 객체는 저장 공간에 할당된 공간을 의미합니다. 이 공간에 접근하기 위해서 자바에서는 객체 참조변수라는 곳에 주소를 담아서 접근을 합니다. 

뒤에서 살펴보겠지만 객체는 클래스라는 것을 통해서 속성과 행위를 가지고 생성이 되는데 하나의 클래스를 통해 다수의 객체가 생성될 수 있습니다. 생성된 객체는 각각이 고유하기 때문에 동일한 속성을 가지고 생성되었더라도 변경사항에 대해서 서로 영향을 주지 않습니다.



## 객체 vs 클래스

그럼 이 객체와 클래스는 무엇이 다른 걸까요? 클래스라는 것은 속성과 행위가 정의되어 있는 개념적인 것입니다. 그래서 이 클래스를 통해 실체화 된것을 객체 또는 인스턴스라고 합니다. 실세계에서 예를 찾아보면 저희들이 살기 위한 집을 짓기 위해서는 설계도가 필요합니다. 이 설계도에 해당하는 것이 클래스이고, 설계도를 통해 지어진 집이 객체라고 할 수 있습니다. 동일한 설계도로 만들어진 집이라고 해도 거기에 살게되는 사람에 따라 집의 내부 구조가 다양하게 변경될 수 있겠죠? 배치된 가구들도 다 다를 것이고, 바닥이나 도배지도 전부 다를 겁니다. 하지만 그렇다고 해서 다른 집에 영향을 주지는 않겠죠. 

이처럼 자바에서의 객체도 동일한 클래스를 통해 만들어지더라도 각각 고유한 속성을 갖게 됩니다. 객체를 만드는 방법은 아래와 같이 new 연산자를 통해 메모리에 객체를 생성한 후 객체참조변수에 반환된 주소를 저장합니다.

이 때 new 연산자에 의해 해당 객체의 생성자가 호출됩니다.



## 메모리 영역

객체가 메모리에 어떻게 생성이 되는지 살펴보도록 하겠습니다. 먼저 런타임 데이터 영역의 메소드 영역을 보시면 클래스에 대한 정보들이 올라가 있습니다. 이 정보들은 JVM이 구동될 때, 그러니까 저희가 만든 프로그램이 실행되는 시점에 클래스로더에 의해 메소드 영역에 클래스 정보가 올라갑니다.  이 메소드 영역은 모든 영역에서 공유하게 됩니다. 보시는 것과 같이 자동차 클래스 파일을 하나 만들었다면 이 class 정보가 메소드 영역에 올라가게 되고, 아래와 같이 자동차 객체를 생성하면 new 연산자에 의해 자동차 객체 하나가 힙영역에 할당이 됩니다. 그리고 할당된 메모리의 주소가 반환되어 myCar라는 객체참조변수에 대입이 되고, myCar 객체가 가지고 있는 name이라는 필드에 접근하기 위해서 도트 연산자를 사용하게 되면 힙영역의 해당 메모리 공간을 가리키게 되고 그 공간에 저장된 name이라는 필드에 접근할 수 있게 됩니다. 여기서는 이 이름 정보를 String carName이라는 지역변수에 대입하고 있는데 이 구문은 어떠한 메소드에서 실행된 것일 겁니다.  이 메소드가 호출되면 자바에서는 스택 프레임이라는 스택 공간이 생성되고 이 안에 지역변수들이 쌓이게 됩니다. 그리고 메소드 실행이 종료되면 이 스택프레임은 자동으로 소멸됩니다. 객체는 그럼 언제 소멸이 될까요? 자바에서의 메모리는 전적으로 JVM에 의해서 관리되고, 해당 객체를 참조하는 변수가 더이상 존재하지 않는다면 GC에 의해서 특정 시점에 일괄적으로 제거됩니다. 힙 영역도 자세히 살펴보면 여러가지 영역으로 구분되고 그 안에 있는 룰에 따라 GC에 의해 남겨지거나 제거됩니다.

그래서 정리를 해보면, 클래스는 메소드 영역에, 객체는 힙영역에 생성되고 객체의 메소드가 수행되면 스택 프레임이 생성됩니다. 그리고 메소드 내의 지역변수들은 스택 프레임의 스택에 쌓이게 되고 메소드 호출 종료시 소멸됩니다.



## 클래스 구성 요소

이제 클래스에 대해서 자세히 살펴보도록 하겠습니다. 먼저 클래스는 필드, 생성자, 메소드로 구성됩니다. 보시는 것처럼 자동차 클래스에서 String 타입의 이름을 필드라고 하고 클래스명과 동일한 이름으로 반환값이 없는 메소드를 생성자라고 하고, 시동 켜기와 같은 어떠한 행위를 수행하는 것을 메소드라고 합니다.



### 필드

필드는 해당 객체의 메서드 전체에서 사용되며 이 객체와 라이프사이클을 같이 합니다. 생성자와 메서드 내에서만 사용되고 종료되면 자동 소멸되는 일반 변수와는 조금 다릅니다.

모든 객체에 동일한 초기값이 주어진다면 필드 선언시에 초기값을 대입하는 식으로 사용할 수 있고, 객체 생성 시점에 외부로부터 어떠한 값을 받아 초기화를 수행한다면 생성자에서 초기화를 수행할 수 있습니다. 

필드에는 값을 대입하지 않아도 컴파일러가 기본 값으로 초기화를 해줍니다. 일반 변수는 대입이 없을 경우 컴파일 에러가 발생하므로 주의하셔야합니다. 



### 생성자

생성자는 new 연산자로 호출되고, 객체 생성 시에 초기화를 담당합니다. 생성자를 작성하지 않더라도 JVM이 기본 생성자를 생성해 줍니다. 생성되는 객체가 상속관계를 가지고 있는 하위 클래스라면 기본 생성자에 super키워드를 통해 상위 클래스의 생성자를 호출합니다. 이 또한 명시하지 않더라도 JVM이 생성해줍니다. 하지만 인자를 가진 생성자가 하나라도 존재한다면 JVM이 기본생성자를 만들어주지 않으므로 주의해야합니다. 

상속 관계의 객체인 경우에는 상위 클래스가 먼저 초기화되고 하위 클래스가 초기화됩니다.



### 메소드

메소드는 객체의 동작에 해당하고 해당 객체의 필드를 읽고 수정하는 역할과 객체간의 상호작용 역할을 합니다. 메소드 내에서는 다른 객체를 생성하거나 인자로 전달받아서 해당 객체와 상호작용을 할 수가 있습니다. 

파라미터를 통해 값을 받을 수 있고 외부로 값을 반환할 수도 있습니다. 메소드는 선언부와 실행 블록으로 구성되는데 선언부를 시그너처라고도 합니다. 이 시그너처는 리턴타입과 메서드 이름, 매개변수를 의미합니다.



## 객체간의 관계

객체들 간에는 여러가지 관계를 가지고 상호작용할 수가 있는데 먼저 집합 관계는 해당 객체의 필드로 다른 객체를 가지고 있는 형태를 말합니다. has a 관계라고도 하는데 이를 제품으로 생각해보면 하나의 객체는 완성품이라고 할 수 있고 다른 객체는 이 완성품의 부품에 해당한다고 볼 수 있습니다. 예를 들어서 자동차라는 제품에 타이어라는 부품을 장착할 수 있는데 여기서 이 자동차와 타이어는 각각 서로다른 객체이고 타이어는 다른 타이어로 교체될 수도 있습니다. 

사용 관계는 객체간의 상호 작용을 의미하는데 어떤 객체의 메소드에서 다른 객체의 메소드를 호출하여 원하는 결과를 얻어낼 수 있습니다. 

그리고 상속 관계는 상위 객체를 기반으로 하위 객체를 생성하는 관계를 말합니다. 여기서 상위 객체는 종류/분류에 해당하고 하위 객체는 분류에 따른 구체적인 사물에 해당합니다. 상속 구조를 설명할 때 분류나 종류로 보지 않고 계층도로 생각하는 경우가 있어서 혼란이 있을 수 있는데, 이에 대해선 상속에 대한 설명을 할 때 살펴보도록 하겠습니다. 



## 객체지향의 4대 특성

이제 객체 지향의 4대 특성인 캡슐화, 상속, 추상화, 다형성에 대해 알아보도록 하겠습니다.  옆에 각 단어들을 영어로도 적어놓았는데 일부 책이나 개발자들 사이에서는 영어단어로 얘기하는 경우도 많기 때문에 같이 알아두시는 것이 좋습니다.  



### 캡슐화

먼저 캡슐화는 정보 은닉의 목적이 있습니다. 저희가 약국에서 약을 사먹을 때  알약을 보면 캡슐 안에 실제 약이 들어있잖아요? 저희는 이 캡슐을 먹기만 하면 되지 안에 어떤 내용이 들어있고, 어떻게 생겼는지를 알 필요도, 알 수도 없습니다. 이와 같이 캡슐화를 통해서 자바의 객체는 노출해야되는 정보와 감춰야할 정보를 지정할 수가 있습니다. 이를 통해 외부의 잘못된 사용으로 인해 객체가 손상되지 않도록 합니다. 이러한 이유 때문에 변화에 유연하게 대응할 수도 있습니다. 

자바에서는 접근 제한자를 통해 정보 은닉을 할 수 있습니다. 먼저 private는 해당 클래스 객체를 제외한 다른 객체에서는 필드나 메서드에 접근할 수가 없습니다.

protected로 선언된 필드와 메서드는 이 클래스를 상속하는 하위 클래스에서 접근할 수 있도록 하고 default는 같은 패키지 내에 속한 클래스의 객체들에 대해서만 접근이 가능합니다. 마지막으로 public은 어디서나 접근 가능한 것을 의미합니다. 감춰야 할 정보들은 private나 default를 많이 사용하고 외부에 노출 할 경우 public을 사용합니다.

모든 필드와 메서드가 public이라면 외부에서 마음대로 접근할 수 있기 때문에 객체의 무결성이 깨질 수 있습니다. 물론 public으로 선언해서 조심히 사용한다면 문제가 생기지 않을 수 있지만 대부분 혼자 개발하는 것이 아니라 협업을 하기 때문에 언제 누가 데이터를 사용할지 알 수가 없습니다. 문제가 발생할 경우 참조하는 모든 부분에 대해 검사를 해야하니 피곤한 작업이 될 것입니다. 이를 방지하기 위해 Getter/Setter 방식을 많이 사용합니다. 관례적으로 필드는 전부 private으로 선언하고, 소문자로 시작하는 public 접근 권한의 get set 메서드를 사용하여 외부에 제공합니다. boolean 타입인 경우 is로 시작하는 것이 관례입니다.



### 상속

